using System.Collections.Generic;
using System.Data;
using System.Configuration;
using FileIO = System.IO;
using System.Reflection;
using System.Diagnostics;
using System;
using System.ComponentModel;
using Infrastructure.Crosscutting.Declaration;

namespace Infrastructure.Crosscutting.Utility
{
    public static class Util
    {
        public static T[] TableToArray<T>(DataTable dt, string colName)
        {
            T[] result = new T[dt.Rows.Count];
            for (int i = 0; i < dt.Rows.Count; i++) result[i] = (T)dt.Rows[i][colName];

            return result;
        }

        public static bool HasEventHandler(object instance, string eventName)
        {
            Type clsType = instance.GetType();

            FieldInfo evtField = clsType.GetField(
                eventName,
                BindingFlags.GetField | BindingFlags.NonPublic | BindingFlags.Instance);

            return evtField.GetValue(instance) != null;
        }

        public static bool IsNullable(Type t)
        {
            return t == typeof(string) || (t.IsGenericType && t.GetGenericTypeDefinition() == typeof(Nullable<>));
        }

        public static Type Nullable2ValueType(Type nullableType)
        {
            return new NullableConverter(nullableType).UnderlyingType;
        }

        public static object ConvertByType(PropertyInfo pi, string val)
        {
            if (string.IsNullOrEmpty(val)) return null;

            Type targetType = pi.PropertyType;
            if (Util.IsNullable(targetType)) targetType = Util.Nullable2ValueType(targetType);

            // enum要做特殊处理
            if (targetType.IsEnum) return Enum.ToObject(targetType, byte.Parse(val));
            else if (targetType == typeof(bool)) return val == "1";
            else return Convert.ChangeType(val, targetType);
        }

        /// <summary>
        /// 返回有顺序的GUID
        /// </summary>
        /// <returns></returns>
        public static Guid NewSequentialGuid()
        {
            byte[] uid = Guid.NewGuid().ToByteArray();
            byte[] binDate = BitConverter.GetBytes(DateTime.UtcNow.Ticks);

            byte[] secuentialGuid = new byte[uid.Length];

            secuentialGuid[0] = uid[0];
            secuentialGuid[1] = uid[1];
            secuentialGuid[2] = uid[2];
            secuentialGuid[3] = uid[3];
            secuentialGuid[4] = uid[4];
            secuentialGuid[5] = uid[5];
            secuentialGuid[6] = uid[6];
            // set the first part of the 8th byte to '1100' so     
            // later we'll be able to validate it was generated by us   
            secuentialGuid[7] = (byte)(0xc0 | (0xf & uid[7]));
            // the last 8 bytes are sequential,    
            // it minimizes index fragmentation   
            // to a degree as long as there are not a large    
            // number of Secuential-Guids generated per millisecond  
            secuentialGuid[9] = binDate[0];
            secuentialGuid[8] = binDate[1];
            secuentialGuid[15] = binDate[2];
            secuentialGuid[14] = binDate[3];
            secuentialGuid[13] = binDate[4];
            secuentialGuid[12] = binDate[5];
            secuentialGuid[11] = binDate[6];
            secuentialGuid[10] = binDate[7];

            return new Guid(secuentialGuid);
        }

        /// <summary>
        /// 按时间生成相应的SysId,使其可以具体可排序性
        /// 生成格式为：年月日时分秒毫秒+5位不重复随机码
        /// </summary>
        /// <returns></returns>
        public static string NewId()
        { 
            Random ran = new Random(Guid.NewGuid().GetHashCode());
              
           return string.Format("{0}{1}", DateTime.Now.ToString("yyyyMMddHHmmss"), ran.Next(10000, 99999));
        }


        ///<summary>
        /// 返回 GUID 用于数据库操作，特定的时间代码可以提高检索效率
        /// </summary>
        /// <returns>COMB (GUID 与时间混合型) 类型 GUID 数据</returns>
        public static Guid NewComb()
        {
            byte[] guidArray = Guid.NewGuid().ToByteArray();

            DateTime baseDate = new DateTime(1900, 1, 1);
            DateTime now = DateTime.Now;

            // Get the days and milliseconds which will be used to build    
            //the byte string    
            TimeSpan days = new TimeSpan(now.Ticks - baseDate.Ticks);
            TimeSpan msecs = now.TimeOfDay;

            // Convert to a byte array        
            // Note that SQL Server is accurate to 1/300th of a    
            // millisecond so we divide by 3.333333    
            byte[] daysArray = BitConverter.GetBytes(days.Days);
            byte[] msecsArray = BitConverter.GetBytes((long)
              (msecs.TotalMilliseconds / 3.333333));

            // Reverse the bytes to match SQL Servers ordering    
            Array.Reverse(daysArray);
            Array.Reverse(msecsArray);

            // Copy the bytes into the guid    
            Array.Copy(daysArray, daysArray.Length - 2, guidArray,
              guidArray.Length - 6, 2);
            Array.Copy(msecsArray, msecsArray.Length - 4, guidArray,
              guidArray.Length - 4, 4);

            return new Guid(guidArray);
        }

        //================================================================
        /// <summary>
        /// 从 SQL SERVER 返回的 GUID 中生成时间信息
        /// </summary>
        /// <param name="guid">包含时间信息的 COMB </param>
        /// <returns>时间</returns>
        public static DateTime GetDateFromComb(System.Guid guid)
        {
            DateTime baseDate = new DateTime(1900, 1, 1);
            byte[] daysArray = new byte[4];
            byte[] msecsArray = new byte[4];
            byte[] guidArray = guid.ToByteArray();

            // Copy the date parts of the guid to the respective byte arrays. 
            Array.Copy(guidArray, guidArray.Length - 6, daysArray, 2, 2);
            Array.Copy(guidArray, guidArray.Length - 4, msecsArray, 0, 4);

            // Reverse the arrays to put them into the appropriate order 
            Array.Reverse(daysArray);
            Array.Reverse(msecsArray);

            // Convert the bytes to ints 
            int days = BitConverter.ToInt32(daysArray, 0);
            int msecs = BitConverter.ToInt32(msecsArray, 0);

            DateTime date = baseDate.AddDays(days);
            date = date.AddMilliseconds(msecs * 3.333333);

            return date;
        }

        #region 对DataRow的数据处理

        /// <summary>
        /// 从DataRow中读取/写入值，值可能是空的情况。
        /// </summary>
        public static T Get<T>(DataRow dr, string colName)
        {
            // 只有表中包含这个列，我们才取值，不然就返回类型的默认值
            if (dr.Table.Columns.Contains(colName) && dr[colName] != DBNull.Value)
                return dr[colName].ToType<T>();// 以前为，(T)dr[colName];因为发现报错,将其调整

            return default(T);
        }

        /// <summary>
        /// 把百分比的值转成格式化的字符串，如0.9=>90%
        /// </summary>
        /// <param name="dr"></param>
        /// <param name="colName"></param>
        /// <returns></returns>
        public static string GetPercent(DataRow dr, string colName)
        { 
            if (dr.Table.Columns.Contains(colName) && dr[colName] != DBNull.Value)
                return string.Format("{0:P0}", dr[colName]);

            return null;
        }

        /// <summary>
        /// 把Money转成格式化的字符串，如12.36=>￥12.36
        /// </summary>
        /// <param name="dr"></param>
        /// <param name="colName"></param>
        /// <returns></returns>
        public static string GetPrice(DataRow dr, string colName)
        {
            if (dr.Table.Columns.Contains(colName) && dr[colName] != DBNull.Value)
                return string.Format("{0:C}", dr[colName]);

            return null;
        }


        /// <summary>
        /// 向DataRow中写入值，值可能是空的情况。
        /// </summary>
        public static void To<T>(T value, DataRow dr, string colName)
        {
            // 因为是保存，必须验证表中是否有这个列
            ConfirmColumn(dr, colName);

            if (value != null)
            {
                if (value.GetType() == typeof(string) && string.IsNullOrWhiteSpace(value.ToString()))
                    dr[colName] = DBNull.Value;
                else
                    dr[colName] = value;
            }
            else
                dr[colName] = DBNull.Value;
        }

        #endregion

        #region Internal Helper

        private static void ConfirmColumn(DataRow dr, string colName)
        {
#if DEBUG
            if (!dr.Table.Columns.Contains(colName))
            {
                StackTrace st = new StackTrace();
                if (st.FrameCount > 2)
                {
                    // get calling frame, not myself
                    StackFrame sf = st.GetFrame(2);
                    MethodBase mb = sf.GetMethod();

                    Debug.Fail(string.Format("{0}.{1}产生错误：表中不包含{2}列.", mb.DeclaringType.Name, mb.Name, colName));
                }
            }
#endif
        }
        #endregion

        #region 实现对集合与对象的复制

        public static void CopyCollection<T>(IEnumerable<T> from, ICollection<T> to)
        {
            if (from == null || to == null || to.IsReadOnly)
            {
                return;
            }

            to.Clear();
            foreach (T element in from)
            {
                to.Add(element);
            }
        }

        public static void CopyModel(object from, object to)
        {
            if (from == null || to == null)
            {
                return;
            }

            PropertyDescriptorCollection fromProperties = TypeDescriptor.GetProperties(from);
            PropertyDescriptorCollection toProperties = TypeDescriptor.GetProperties(to);

            foreach (PropertyDescriptor fromProperty in fromProperties)
            {
                PropertyDescriptor toProperty = toProperties.Find(fromProperty.Name, true /* ignoreCase */);
                if (toProperty != null && !toProperty.IsReadOnly)
                {
                    // Can from.Property reference just be assigned directly to to.Property reference?
                    bool isDirectlyAssignable = toProperty.PropertyType.IsAssignableFrom(fromProperty.PropertyType);
                    // Is from.Property just the nullable form of to.Property?
                    bool liftedValueType = (isDirectlyAssignable) ? false : (Nullable.GetUnderlyingType(fromProperty.PropertyType) == toProperty.PropertyType);

                    if (isDirectlyAssignable || liftedValueType)
                    {
                        object fromValue = fromProperty.GetValue(from);
                        if (isDirectlyAssignable || (fromValue != null && liftedValueType))
                        {
                            toProperty.SetValue(to, fromValue);
                        }
                    }
                }
            }
        } 

        #endregion

    }
}
